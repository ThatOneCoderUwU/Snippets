local a=Instance.new"Folder"
a.Name="GuiLib"
local b=Instance.new"Folder"
b.Name="Classes"
b.Parent=a
local c=Instance.new"ModuleScript"
c.Name="CheckboxLabel"
c.Source="--[[\r\nClasses.CheckboxLabel\r\n\r\nThis class creates a single checkbox label\r\n\r\nConstructors:\r\n\tnew(frame [instance])\r\n\t\t>\r\n\tCreate(text)\r\n\t\t> Creates a CheckboxLabel from the text provided.\r\n\r\nProperties:\r\n\tFrame [instance]\r\n\t\t> The container frame for the CheckboxLabel. Can be used for positioning and resizing.\r\n\tButton [instance]\r\n \t\t> The button used to track when the user clicks on the checkbox button or not\r\n\r\nMethods:\r\n\t:GetValue() [boolean]\r\n\t\t> Returns whether the 0checkbox is selected or not.\r\n\t:SetValue(bool [boolean]) [void]\r\n\t\t> Sets if the checkbox is selected or not.\r\n\t:Destroy() [void]\r\n\t\t> Destroys the RadioButtonLabel and all the events, etc that were running it.\r\n\r\nEvents:\r\n\t.Changed:Connect(function(bool [boolean])\r\n\t\t> Fired when the user clicks the checkbox.\r\n--]]\r\n\r\n\r\n-- CONSTANTS\r\n\r\nlocal GuiLib = script.Parent.Parent\r\nlocal Lazy = require(GuiLib:WaitForChild(\"LazyLoader\"))\r\nlocal Defaults = GuiLib:WaitForChild(\"Defaults\")\r\n\r\nlocal CHECKBOX_LABEL = Defaults:WaitForChild(\"CheckboxLabel\")\r\n\r\n-- Class\r\n\r\nlocal CheckboxLabelClass = {}\r\nCheckboxLabelClass.__index = CheckboxLabelClass\r\nCheckboxLabelClass.__type = \"CheckboxLabel\"\r\n\r\nfunction CheckboxLabelClass:__tostring()\r\n\treturn CheckboxLabelClass.__type\r\nend\r\n\r\n-- Public Constructors\r\n\r\nfunction CheckboxLabelClass.new(frame)\r\n\tlocal self = setmetatable({}, CheckboxLabelClass)\r\n\t\r\n\tself._Maid = Lazy.Utilities.Maid.new()\r\n\tself._ChangedBind = Instance.new(\"BindableEvent\")\r\n\t\r\n\tself.Frame = frame\r\n\tself.Button = frame.CheckContainer.CheckButton\r\n\tself.Changed = self._ChangedBind.Event\r\n\t\r\n\tinit(self)\r\n\tself:SetValue(false)\r\n\t\r\n\treturn self\r\nend\r\n\r\nfunction CheckboxLabelClass.Create(text)\r\n\tlocal cbLabel = CHECKBOX_LABEL:Clone()\r\n\tcbLabel.Label.Text = text\r\n\treturn CheckboxLabelClass.new(cbLabel)\r\nend\r\n\r\n-- Private Methods\r\n\r\nfunction init(self)\r\n\tlocal label = self.Frame.Label\r\n\tlocal container = self.Frame.CheckContainer\r\n\tlocal checkmark = self.Button.Checkmark\r\n\t\r\n\tlocal function contentSizeUpdate()\r\n\t\tlocal absSize = self.Frame.AbsoluteSize\r\n\t\tlocal ratio = absSize.y / absSize.x\r\n\t\tcontainer.Size = UDim2.new(ratio, 0, 1, 0)\r\n\t\tlabel.Size = UDim2.new(1 - ratio, -10, 1, 0)\r\n\t\tlabel.Position = UDim2.new(ratio, 10, 0, 0)\r\n\tend\r\n\t\r\n\tcontentSizeUpdate()\r\n\tself._Maid:Mark(self.Frame:GetPropertyChangedSignal(\"AbsoluteSize\"):Connect(contentSizeUpdate))\r\n\t\r\n\tself._Maid:Mark(self.Button.Activated:Connect(function()\r\n\t\tself:SetValue(not checkmark.Visible)\r\n\tend))\r\nend\r\n\r\n-- Public Methods\r\n\r\nfunction CheckboxLabelClass:GetValue()\r\n\treturn self.Button.Checkmark.Visible\r\nend\r\n\r\nfunction CheckboxLabelClass:SetValue(bool)\r\n\tbool = not not bool\r\n\t\r\n\tlocal container = self.Frame.CheckContainer\r\n\tlocal colorA = container.BackgroundColor3\r\n\tlocal colorB = container.BorderColor3\r\n\tlocal colorC = container.Outline.BackgroundColor3\r\n\t\r\n\tlocal outlineColor = bool and colorB or colorC\r\n\tif (bool and container.CheckButton.BackgroundTransparency == 1) then\r\n\t\toutlineColor = colorC\r\n\tend\r\n\t\r\n\tfor _, child in next, container.Outline:GetChildren() do\r\n\t\tchild.BackgroundColor3 = outlineColor\r\n\tend\r\n\t\r\n\tcontainer.CheckButton.BackgroundColor3 = bool and colorB or colorA\r\n\tcontainer.CheckButton.Checkmark.Visible = bool\r\n\t\r\n\tself._ChangedBind:Fire(bool)\r\nend\r\n\r\nfunction CheckboxLabelClass:Destroy()\r\n\tself._Maid:Sweep()\r\n\tself.Frame:Destroy()\r\n\tself.Changed = nil\r\nend\r\n\r\n--\r\n\r\nreturn CheckboxLabelClass"
c.Parent=b
local d=Instance.new"ModuleScript"
d.Name="Dragger"
d.Source="-- Meant for internal use, no documentation given\r\n\r\n-- CONSTANTS\r\n\r\nlocal GuiLib = script.Parent.Parent\r\nlocal Lazy = require(GuiLib:WaitForChild(\"LazyLoader\"))\r\n\r\nlocal UIS = game:GetService(\"UserInputService\")\r\nlocal RUNSERVICE = game:GetService(\"RunService\")\r\n\r\nlocal DEADZONE2 = 0.15^2\r\nlocal FLIP_THUMB = Vector3.new(1, -1, 1)\r\n\r\nlocal VALID_PRESS = {\r\n\t[Enum.UserInputType.MouseButton1] = true;\r\n\t[Enum.UserInputType.Touch] = true;\r\n}\r\n\r\nlocal VALID_MOVEMENT = {\r\n\t[Enum.UserInputType.MouseMovement] = true;\r\n\t[Enum.UserInputType.Touch] = true;\r\n}\r\n\r\n-- Class\r\n\r\nlocal DraggerClass = {}\r\nDraggerClass.__index = DraggerClass\r\nDraggerClass.__type = \"Dragger\"\r\n\r\nfunction DraggerClass:__tostring()\r\n\treturn DraggerClass.__type\r\nend\r\n\r\n-- Public Constructors\r\n\r\nfunction DraggerClass.new(element)\r\n\tlocal self = setmetatable({}, DraggerClass)\r\n\t\r\n\tself._Maid = Lazy.Utilities.Maid.new()\r\n\tself._DragBind = Instance.new(\"BindableEvent\")\r\n\tself._StartBind = Instance.new(\"BindableEvent\")\r\n\tself._StopBind = Instance.new(\"BindableEvent\")\r\n\t\r\n\tself.Element = element\r\n\tself.IsDragging = false\r\n\tself.DragChanged = self._DragBind.Event\r\n\tself.DragStart = self._StartBind.Event\r\n\tself.DragStop = self._StopBind.Event\r\n\t\r\n\tinit(self)\r\n\t\r\n\treturn self\r\nend\r\n\r\n-- Private Methods\r\n\r\nfunction init(self)\r\n\tlocal element = self.Element\r\n\tlocal maid = self._Maid\r\n\tlocal dragBind = self._DragBind\r\n\tlocal lastMousePosition = Vector3.new()\r\n\t\r\n\tmaid:Mark(self._DragBind)\r\n\tmaid:Mark(self._StartBind)\r\n\tmaid:Mark(self._StopBind)\r\n\t\r\n\tmaid:Mark(element.InputBegan:Connect(function(input)\r\n\t\tif (VALID_PRESS[input.UserInputType]) then\r\n\t\t\tlastMousePosition = input.Position\r\n\t\t\tself.IsDragging = true\r\n\t\t\tself._StartBind:Fire()\r\n\t\tend\r\n\tend))\r\n\t\r\n\tmaid:Mark(UIS.InputEnded:Connect(function(input)\r\n\t\tif (VALID_PRESS[input.UserInputType]) then\r\n\t\t\tself.IsDragging = false\r\n\t\t\tself._StopBind:Fire()\r\n\t\tend\r\n\tend))\r\n\t\r\n\tmaid:Mark(UIS.InputChanged:Connect(function(input, process)\r\n\t\tif (self.IsDragging) then\r\n\t\t\tif (VALID_MOVEMENT[input.UserInputType]) then\r\n\t\t\t\tlocal delta = input.Position - lastMousePosition\r\n\t\t\t\tlastMousePosition = input.Position\r\n\t\t\t\tdragBind:Fire(element, input, delta)\r\n\t\t\tend\r\n\t\tend\r\n\tend))\r\nend\r\n\r\n-- Public Methods\r\n\r\nfunction DraggerClass:Destroy()\r\n\tself._Maid:Sweep()\r\n\tself.DragChanged = nil\r\n\tself.DragStart = nil\r\n\tself.DragStop = nil\r\n\tself.Element = nil\r\nend\r\n\r\n--\r\n\r\nreturn DraggerClass"
d.Parent=b
local e=Instance.new"ModuleScript"
e.Name="Dropdown"
e.Source="--[[\r\nClasses.Dropdown\r\n\r\nThis class creates a dropdown that the user can select a list of options from.\r\n\r\nConstructors:\r\n\tnew(frame [instance], listFrame [instance])\r\n\t\t>\r\n\tCreate(list[] [string], max [integer])\r\n\t\t> Creates a dropdown from the list with a max scrolling number.\r\n\r\nProperties:\r\n\tFrame [instance]\r\n\t\t> The container frame for the dropdown. Can be used for positioning and resizing.\r\n\tListFrame [instance]\r\n \t\t> The contaienr frame for the dropdown list. Parented underneath the main container frame.\r\n\r\nMethods:\r\n\t:Set(option [instance]) [void]\r\n\t\t> option is a child of the ListFrame and you can set it as the selected option of the dropdown with this method\r\n\t:Get() [instance]\r\n\t\t> Returns the selected option frame (which is again, a child of the ListFrame)\r\n\t:Show(bool [boolean])\r\n\t\t> Set whether the dropdown list is visible or not.\r\n\t:Destroy() [void]\r\n\t\t> Destroys the RadioButtonGroup and all the events, etc that were running it.\r\n\r\nEvents:\r\n\t.Changed:Connect(function(option [instance])\r\n\t\t> Fired when the user selects a new option from the dropdown list.\r\n--]]\r\n\r\n\r\n-- CONSTANTS\r\n\r\nlocal GuiLib = script.Parent.Parent\r\nlocal Lazy = require(GuiLib:WaitForChild(\"LazyLoader\"))\r\nlocal Defaults = GuiLib:WaitForChild(\"Defaults\")\r\n\r\nlocal UIS = game:GetService(\"UserInputService\")\r\n\r\nlocal VALID_PRESS = {\r\n\t[Enum.UserInputType.MouseButton1] = true;\r\n\t[Enum.UserInputType.Touch] = true;\r\n}\r\n\r\nlocal ARROW_UP = \"rbxassetid://5154078925\"\r\nlocal ARROW_DOWN = \"rbxassetid://5143165549\"\r\n\r\nlocal DROP_BUTTON = Defaults:WaitForChild(\"DropdownButton\")\r\n\r\n-- Class\r\n\r\nlocal DropdownClass = {}\r\nDropdownClass.__index = DropdownClass\r\nDropdownClass.__type = \"Dropdown\"\r\n\r\nfunction DropdownClass:__tostring()\r\n\treturn DropdownClass.__type\r\nend\r\n\r\n-- Public Constructors\r\n\r\nfunction DropdownClass.new(button, listFrame)\r\n\tlocal self = setmetatable({}, DropdownClass)\r\n\t\r\n\tself._Maid = Lazy.Utilities.Maid.new()\r\n\tself._ChangedBind = Instance.new(\"BindableEvent\")\r\n\tself._Options = {}\r\n\tself._Selected = nil\r\n\t\r\n\tself.Button = button\r\n\tself.ListFrame = listFrame\r\n\tself.Changed = self._ChangedBind.Event\r\n\t\r\n\tinit(self)\r\n\tself:Set(self._Options[1])\r\n\t\r\n\treturn self\r\nend\r\n\r\nfunction DropdownClass.Create(list, max)\r\n\tmax = max or #list\r\n\t\r\n\tlocal button = DROP_BUTTON:Clone()\r\n\tlocal listFrame = Lazy.Constructors.List.Create(list, max)\r\n\t\r\n\tlistFrame.Position = UDim2.new(0, 0, 1, 0)\r\n\tlistFrame.Size = UDim2.new(1, 0, max, 0)\r\n\tlistFrame.Visible = false\r\n\tlistFrame.Parent = button\r\n\t\r\n\treturn DropdownClass.new(button, listFrame)\r\nend\r\n\r\n-- Private Methods\r\n\r\nfunction init(self)\r\n\tlocal button = self.Button\r\n\tlocal listFrame = self.ListFrame\r\n\t\r\n\tlocal function contentSizeUpdate()\r\n\t\tlocal absSize = button.AbsoluteSize\r\n\t\tlocal ratio = absSize.y / absSize.x\r\n\t\t\r\n\t\tbutton.Arrow.Size = UDim2.new(ratio, 0, 1, 0)\r\n\t\tbutton.Option.Size = UDim2.new(1 - ratio, -12, 1, 0)\r\n\tend\r\n\t\r\n\tcontentSizeUpdate()\r\n\tself._Maid:Mark(button:GetPropertyChangedSignal(\"AbsoluteSize\"):Connect(contentSizeUpdate))\r\n\t\r\n\tfor i, optionButton in next, listFrame.ScrollFrame:GetChildren() do\r\n\t\tself._Options[i] = optionButton\r\n\t\toptionButton.Activated:Connect(function()\r\n\t\t\tself:Set(optionButton)\r\n\t\tend)\r\n\tend\r\n\r\n\tself._Maid:Mark(button.Activated:Connect(function()\r\n\t\tself:Show(not listFrame.Visible)\r\n\tend))\r\n\t\r\n\tself._Maid:Mark(UIS.InputBegan:Connect(function(input)\r\n\t\tif (VALID_PRESS[input.UserInputType]) then\r\n\t\t\tlocal p = input.Position\r\n\t\t\tlocal p2 = Vector2.new(p.x, p.y)\r\n\t\t\t\r\n\t\t\tif (listFrame.Visible and not (isInFrame(listFrame, p2) or isInFrame(button, p2))) then\r\n\t\t\t\tself:Show(false)\r\n\t\t\tend\r\n\t\tend\r\n\tend))\r\nend\r\n\r\nfunction isInFrame(frame, pos)\r\n\tlocal fPos = frame.AbsolutePosition\r\n\tlocal fSize = frame.AbsoluteSize\r\n\tlocal d = pos - fPos\r\n\treturn (d.x >= 0 and d.x <= fSize.x and d.y >= 0 and d.y <= fSize.y)\r\nend\r\n\r\n-- Public Methods\r\n\r\nfunction DropdownClass:Set(option)\r\n\tif (self._Selected ~= option) then\r\n\t\tself._Selected = option\r\n\t\tself._ChangedBind:Fire(option)\r\n\t\tself.Button.Option.Text = option.Label.Text\r\n\tend\r\n\tself:Show(false)\r\nend\r\n\r\nfunction DropdownClass:Get()\r\n\treturn self._Selected\r\nend\r\n\r\nfunction DropdownClass:Show(bool)\r\n\tself.Button.Arrow.Image = bool and ARROW_UP or ARROW_DOWN\r\n\tself.ListFrame.Visible = bool\r\nend\r\n\r\nfunction DropdownClass:Destroy()\r\n\tself._Maid:Sweep()\r\n\tself._Changed = nil\r\n\tself._Options = nil\r\n\tself._Selected = nil\r\n\tself.Button:Destroy()\r\nend\r\n\r\n--\r\n\r\nreturn DropdownClass"
e.Parent=b
local f=Instance.new"ModuleScript"
f.Name="RadioButtonGroup"
f.Source="--[[\r\nClasses.RadioButtonGroup\r\n\r\nThis class creates a list of radio buttons that the user can select from.\r\n\r\nConstructors:\r\n\tnew(frame [instance], buttons[] [RadioButtonLabel])\r\n\tCreate(list[] [string], max [integer])\r\n\t\t> Creates a RadioButtonGroup from the list with a max scrolling number.\r\n\r\nProperties:\r\n\tFrame [instance]\r\n\t\t> The container frame for the RadioButtonGroup. Can be used for positioning and resizing.\r\n\tRadioButtons[] [RadioButtonLabel]\r\n \t\t> An array of the RadioButtonLabels that are used in the RadioButtonGroup.\r\n\r\nMethods:\r\n\t:GetActiveRadio() [RadioButtonLabel]\r\n\t\t> Returns the currently selected RadioButtonLabel\r\n\t:Destroy() [void]\r\n\t\t> Destroys the RadioButtonGroup and all the events, etc that were running it.\r\n\r\nEvents:\r\n\t.Changed:Connect(function(old [RadioButtonLabel], new [RadioButtonLabel])\r\n\t\t> When the selected radio button is changed in the radio button group this event fires\r\n--]]\r\n\r\n-- CONSTANTS\r\n\r\nlocal GuiLib = script.Parent.Parent\r\nlocal Lazy = require(GuiLib:WaitForChild(\"LazyLoader\"))\r\n\r\n-- Class\r\n\r\nlocal RadioButtonGroupClass = {}\r\nRadioButtonGroupClass.__index = RadioButtonGroupClass\r\nRadioButtonGroupClass.__type = \"RadioButtonLabel\"\r\n\r\nfunction RadioButtonGroupClass:__tostring()\r\n\treturn RadioButtonGroupClass.__type\r\nend\r\n\r\n-- Public Constructors\r\n\r\nfunction RadioButtonGroupClass.new(frame, radioButtons)\r\n\tlocal self = setmetatable({}, RadioButtonGroupClass)\r\n\t\r\n\tself._Maid = Lazy.Utilities.Maid.new()\r\n\tself._ChangedBind = Instance.new(\"BindableEvent\")\r\n\tself._ActiveRadio = radioButtons[1]\r\n\t\r\n\tself.Frame = frame\r\n\tself.RadioButtons = radioButtons\r\n\tself.Changed = self._ChangedBind.Event\r\n\t\r\n\tinit(self)\r\n\t\r\n\treturn self\r\nend\r\n\r\nfunction RadioButtonGroupClass.Create(list, max)\r\n\tlocal radios = {}\r\n\t\r\n\tlocal function instanceFunc(index, option)\r\n\t\tlocal radio = Lazy.Classes.RadioButtonLabel.Create(option)\r\n\t\tradio.Frame.LayoutOrder = index\r\n\t\tradios[index] = radio\r\n\t\treturn radio.Frame\r\n\tend\r\n\t\r\n\tlocal frame = Lazy.Constructors.List.Create(list, max or #list, Enum.FillDirection.Vertical, UDim.new(0, 5), instanceFunc)\r\n\t\r\n\treturn RadioButtonGroupClass.new(frame, radios)\r\nend\r\n\r\n-- Private Methods\r\n\r\nfunction init(self)\r\n\tfor _, radio in next, self.RadioButtons do\r\n\t\tradio:SetValue(false)\r\n\t\tself._Maid:Mark(radio.Button.Activated:Connect(function()\r\n\t\t\tlocal old = self._ActiveRadio\r\n\t\t\t\r\n\t\t\tself._ActiveRadio:SetValue(false)\r\n\t\t\tself._ActiveRadio = radio\r\n\t\t\tself._ActiveRadio:SetValue(true)\r\n\t\t\t\r\n\t\t\tself._ChangedBind:Fire(old, radio)\r\n\t\tend))\r\n\tend\r\n\t\r\n\tself._ActiveRadio:SetValue(true)\r\nend\r\n\r\n-- Public Methods\r\n\r\nfunction RadioButtonGroupClass:GetActiveRadio()\r\n\treturn self._ActiveRadio\r\nend\r\n\r\nfunction RadioButtonGroupClass:Destroy()\r\n\tself._Maid:Sweep()\r\n\tself.Frame:Destroy()\r\nend\r\n\r\n--\r\n\r\nreturn RadioButtonGroupClass"
f.Parent=b
local g=Instance.new"ModuleScript"
g.Name="RadioButtonLabel"
g.Source="--[[\r\nClasses.RadioButtonLabel\r\n\r\nThis class creates a single radio button label.\r\n\r\nConstructors:\r\n\tnew(frame [instance])\r\n\t\t>\r\n\tCreate(text)\r\n\t\t> Creates a RadioButtonLabel from the text provided.\r\n\r\nProperties:\r\n\tFrame [instance]\r\n\t\t> The container frame for the RadioButtonLabel. Can be used for positioning and resizing.\r\n\tButton [instance]\r\n \t\t> The button used to track when the user clicks on the radio button or not\r\n\r\nMethods:\r\n\t:GetValue() [boolean]\r\n\t\t> Returns whether the button is selected or not.\r\n\t:SetValue(bool [boolean]) [void]\r\n\t\t> Sets if the button is selected or not\r\n\t:Destroy() [void]\r\n\t\t> Destroys the RadioButtonLabel and all the events, etc that were running it.\r\n--]]\r\n\r\n-- CONSTANTS\r\n\r\nlocal GuiLib = script.Parent.Parent\r\nlocal Lazy = require(GuiLib:WaitForChild(\"LazyLoader\"))\r\nlocal Defaults = GuiLib:WaitForChild(\"Defaults\")\r\n\r\nlocal RADIOBUTTON_LABEL = Defaults:WaitForChild(\"RadioButtonLabel\")\r\n\r\n-- Class\r\n\r\nlocal RadioButtonLabelClass = {}\r\nRadioButtonLabelClass.__index = RadioButtonLabelClass\r\nRadioButtonLabelClass.__type = \"RadioButtonLabel\"\r\n\r\nfunction RadioButtonLabelClass:__tostring()\r\n\treturn RadioButtonLabelClass.__type\r\nend\r\n\r\n-- Public Constructors\r\n\r\nfunction RadioButtonLabelClass.new(frame)\r\n\tlocal self = setmetatable({}, RadioButtonLabelClass)\r\n\t\r\n\tself._Maid = Lazy.Utilities.Maid.new()\r\n\t\r\n\tself.Frame = frame\r\n\tself.Button = frame.RadioContainer.RadioButton\r\n\t\r\n\tinit(self)\r\n\tself:SetValue(false)\r\n\t\r\n\treturn self\r\nend\r\n\r\nfunction RadioButtonLabelClass.Create(text)\r\n\tlocal cbLabel = RADIOBUTTON_LABEL:Clone()\r\n\tcbLabel.Label.Text = text\r\n\treturn RadioButtonLabelClass.new(cbLabel)\r\nend\r\n\r\n-- Private Methods\r\n\r\nfunction init(self)\r\n\tlocal label = self.Frame.Label\r\n\tlocal container = self.Frame.RadioContainer\r\n\t\r\n\tlocal function contentSizeUpdate()\r\n\t\tlocal absSize = self.Frame.AbsoluteSize\r\n\t\tlocal ratio = absSize.y / absSize.x\r\n\t\tcontainer.Size = UDim2.new(ratio, 0, 1, 0)\r\n\t\tlabel.Size = UDim2.new(1 - ratio, -10, 1, 0)\r\n\t\tlabel.Position = UDim2.new(ratio, 10, 0, 0)\r\n\tend\r\n\t\r\n\tcontentSizeUpdate()\r\n\tself._Maid:Mark(self.Frame:GetPropertyChangedSignal(\"AbsoluteSize\"):Connect(contentSizeUpdate))\r\nend\r\n\r\n-- Public Methods\r\n\r\nfunction RadioButtonLabelClass:GetValue()\r\n\treturn self.Button.Circle.Visible\r\nend\r\n\r\nfunction RadioButtonLabelClass:SetValue(bool)\r\n\tbool = not not bool\r\n\t\r\n\tlocal container = self.Frame.RadioContainer\r\n\tlocal colorA = container.BorderColor3\r\n\tlocal colorB = container.BackgroundColor3\r\n\t\r\n\tcontainer.Outline.ImageColor3 = bool and colorA or colorB\r\n\tcontainer.RadioButton.Circle.Visible = bool\r\nend\r\n\r\nfunction RadioButtonLabelClass:Destroy()\r\n\tself._Maid:Sweep()\r\n\tself.Frame:Destroy()\r\nend\r\n\r\n--\r\n\r\nreturn RadioButtonLabelClass"
g.Parent=b
local h=Instance.new"ModuleScript"
h.Name="Slider"
h.Source="--[[\r\nClasses.Slider\r\n\r\nThis class creates a slider object which can be dragged for different values.\r\n\r\nConstructors:\r\n\tnew(frame [instance], axis [string])\r\n\t\t> Slider frames must have the following format:\r\n\t\t\t>> SliderFrame\r\n\t\t\t\t>>> Dragger\r\n\t\t\t\t>>> Background\r\n\t\t> axis defines if the slider is horizontal \"x\" or vertical \"y\"\r\n\tCreate(axis [string])\r\n\t\t> Creates a slider frame from the default, simply define whether it's horizontal \"x\" or vertical \"y\".\r\n\r\nProperties:\r\n\tFrame [instance]\r\n\t\t> The container frame for the slider. Can be used for positioning and resizing.\r\n\tInterval [number] [0, 1]\r\n \t\t> Set this to force an interval step on the slider. For example if you only wanted steps of 1/10th then you'd write\r\n\t\t> Slider.Interval = 0.1\r\n\tIsActive [boolean]\r\n\t\t> When true the slider can be interacted with by the user, when false its values can only be set by the developer.\r\n\tTweenClick [boolean]\r\n\t\t> If true then when the user clicks on the slider the dragger will tween to that target. If not it will be instant.\r\n\tInverted [boolean]\r\n\t\t> If true then the value of the slider will be inverted (e.g. when horizontal the right-most position will be zero and left-most 1)\r\n\t\t> This is useful for when you have a vertical slider as typically users envision the down-most position to be zero.\r\n\r\nMethods:\r\n\t:Get() [number]\r\n\t\t> Returns the slider position from 0 to 1\r\n\t:Set(value [number], doTween [boolean]) [void]\r\n\t\t> Sets the slider to a specific position or closest possible if interval > 0. If doTween is true then the slider will tween to that position.\r\n\t:Destroy() [void]\r\n\t\t> Destroys the slider frame and all the events, etc that were running it\r\n\r\nEvents:\r\n\t.Changed:Connect(function(value [number])\r\n\t\t> When the slider's position changes this fires the slider's current position\r\n\t.Clicked:Connect(function(value [number])\r\n\t\t> When the user clicks somewhere on the slider this fires the clicked position\r\n\t.DragStart:Connect(function()\r\n\t\t> Fires when the user starts dragging the slider\r\n\t.DragStop:Connect(function()\r\n\t\t> Fires when the user stops dragging the slider\r\n--]]\r\n\r\n-- CONSTANTS\r\n\r\nlocal GuiLib = script.Parent.Parent\r\nlocal Lazy = require(GuiLib:WaitForChild(\"LazyLoader\"))\r\nlocal Defaults = GuiLib:WaitForChild(\"Defaults\")\r\n\r\nlocal UIS = game:GetService(\"UserInputService\")\r\nlocal RUNSERVICE = game:GetService(\"RunService\")\r\n\r\nlocal SLIDER_FRAMEX = Defaults:WaitForChild(\"SliderFrameX\")\r\nlocal SLIDER_FRAMEY = Defaults:WaitForChild(\"SliderFrameY\")\r\n\r\nlocal XBOX_STEP = 0.01\r\nlocal DEBOUNCE_TICK = 0.1\r\nlocal XBOX_DEADZONE = 0.35\r\nlocal THUMBSTICK = Enum.KeyCode.Thumbstick2\r\n\r\n-- Class\r\n\r\nlocal SliderClass = {}\r\nSliderClass.__index = SliderClass\r\nSliderClass.__type = \"Slider\"\r\n\r\nfunction SliderClass:__tostring()\r\n\treturn SliderClass.__type\r\nend\r\n\r\n-- Public Constructors\r\n\r\nfunction SliderClass.new(sliderFrame, axis)\r\n\tlocal self = setmetatable({}, SliderClass)\r\n\t\r\n\tself._Maid = Lazy.Utilities.Maid.new()\r\n\tself._Spring = Lazy.Utilities.Spring.new(1, 0.1, 1, 0)\r\n\tself._Axis = axis or \"x\"\r\n\tself._ChangedBind = Instance.new(\"BindableEvent\")\r\n\tself._ClickedBind = Instance.new(\"BindableEvent\")\r\n\t\r\n\tself.Interval = 0\r\n\tself.IsActive = true\r\n\tself.TweenClick = true\r\n\tself.Inverted = false\r\n\t\r\n\tself.Frame = sliderFrame\r\n\tself.Changed = self._ChangedBind.Event\r\n\tself.Clicked = self._ClickedBind.Event\r\n\tself.DragStart = nil\r\n\tself.DragStop = nil\r\n\t\r\n\tinit(self)\r\n\tself:Set(0.5)\r\n\t\r\n\treturn self\r\nend\r\n\r\nfunction SliderClass.Create(axis)\r\n\tlocal slider = nil\r\n\t\r\n\tif (not axis or axis == \"x\") then\r\n\t\tslider = SliderClass.new(SLIDER_FRAMEX:Clone(), axis)\r\n\telse\r\n\t\tslider = SliderClass.new(SLIDER_FRAMEY:Clone(), axis)\r\n\t\tslider.Inverted = true\r\n\tend\r\n\t\r\n\treturn slider\r\nend\r\n\r\n-- Private Methods\r\n\r\nfunction init(self)\r\n\tlocal frame = self.Frame\r\n\tlocal dragger = frame.Dragger\r\n\tlocal background = frame.Background\r\n\t\r\n\tlocal axis = self._Axis\r\n\tlocal maid = self._Maid\r\n\tlocal spring = self._Spring\r\n\tlocal dragTracker = Lazy.Classes.Dragger.new(dragger)\r\n\t\r\n\tself.DragStart = dragTracker.DragStart\r\n\tself.DragStop = dragTracker.DragStop\r\n\t\r\n\tmaid:Mark(frame)\r\n\tmaid:Mark(self._ChangedBind)\r\n\tmaid:Mark(self._ClickedBind)\r\n\tmaid:Mark(function() dragTracker:Destroy() end)\r\n\t\r\n\t-- Get bounds and background size scaled accordingly for calculations\r\n\tlocal function setUdim2(a, b)\r\n\t\tif (axis == \"y\") then a, b = b, a end\r\n\t\treturn UDim2.new(a, 0, b, 0)\r\n\tend\r\n\t\r\n\tlocal last = -1\r\n\tlocal bPos, bSize\r\n\tlocal function updateBounds()\r\n\t\tbPos, bSize = getBounds(self)\r\n\t\tbackground.Size = setUdim2(bSize / frame.AbsoluteSize[axis], 1)\r\n\t\tlast = -1\r\n\tend\r\n\t\r\n\tupdateBounds()\r\n\tmaid:Mark(frame:GetPropertyChangedSignal(\"AbsoluteSize\"):Connect(updateBounds))\r\n\tmaid:Mark(frame:GetPropertyChangedSignal(\"AbsolutePosition\"):Connect(updateBounds))\r\n\tmaid:Mark(frame:GetPropertyChangedSignal(\"Parent\"):Connect(updateBounds))\r\n\t\r\n\t-- Move the slider when the xbox moves it\r\n\tlocal xboxDir = 0\r\n\tlocal xboxTick = 0\r\n\tlocal xboxSelected = false\r\n\t\r\n\tmaid:Mark(dragger.SelectionGained:Connect(function()\r\n\t\txboxSelected = true\r\n\tend))\r\n\t\r\n\tmaid:Mark(dragger.SelectionLost:Connect(function()\r\n\t\txboxSelected = false\r\n\tend))\r\n\t\r\n\tmaid:Mark(UIS.InputChanged:Connect(function(input, process)\r\n\t\tif (process and input.KeyCode == THUMBSTICK) then\r\n\t\t\tlocal pos = input.Position\r\n\t\t\txboxDir = math.abs(pos[axis]) > XBOX_DEADZONE and math.sign(pos[axis]) or 0\r\n\t\tend\r\n\tend))\r\n\t\r\n\t-- Move the slider when we drag it\r\n\tmaid:Mark(dragTracker.DragChanged:Connect(function(element, input, delta)\r\n\t\tif (self.IsActive) then\r\n\t\t\tself:Set((input.Position[axis] - bPos) / bSize, false)\r\n\t\tend\r\n\tend))\r\n\t\r\n\t-- Move the slider when we click somewhere on the bar\r\n\tmaid:Mark(frame.InputBegan:Connect(function(input)\r\n\t\tif (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch) then\r\n\t\t\tlocal t = (input.Position[axis] - bPos) / bSize\r\n\t\t\tself._ClickedBind:Fire(math.clamp(t, 0, 1))\r\n\t\t\tif (self.IsActive) then\r\n\t\t\t\tself:Set(t, self.TweenClick)\r\n\t\t\tend\r\n\t\tend\r\n\tend))\r\n\t\r\n\t-- position the slider\r\n\tmaid:Mark(RUNSERVICE.RenderStepped:Connect(function(dt)\r\n\t\tif (xboxSelected) then\r\n\t\t\tlocal t = tick()\r\n\t\t\tif (self.Interval <= 0) then\r\n\t\t\t\tself:Set(self:Get() + xboxDir*XBOX_STEP*dt*60)\r\n\t\t\telseif (t - xboxTick > DEBOUNCE_TICK) then\r\n\t\t\t\txboxTick = t\r\n\t\t\t\tself:Set(self:Get() + self.Interval*xboxDir)\r\n\t\t\tend\r\n\t\tend\r\n\t\t\r\n\t\tspring:Update(dt)\r\n\t\tlocal x = spring.x\r\n\t\tif (x ~= last) then\r\n\t\t\tlocal scalePos = (bPos + (x * bSize) - frame.AbsolutePosition[axis]) / frame.AbsoluteSize[axis]\r\n\t\t\tdragger.Position = setUdim2(scalePos, 0.5)\r\n\t\t\tself._ChangedBind:Fire(self:Get())\r\n\t\t\tlast = x\r\n\t\tend\r\n\tend))\r\nend\r\n\r\nfunction getBounds(self)\r\n\tlocal frame = self.Frame\r\n\tlocal dragger = frame.Dragger\r\n\tlocal axis = self._Axis\r\n\t\r\n\tlocal pos = frame.AbsolutePosition[axis] + dragger.AbsoluteSize[axis]/2\r\n\tlocal size = frame.AbsoluteSize[axis] - dragger.AbsoluteSize[axis]\r\n\t\r\n\treturn pos, size\r\nend\r\n\r\n-- Public Methods\r\n\r\nfunction SliderClass:Get()\r\n\tlocal t = self._Spring.x\r\n\tif (self.Inverted) then t = 1 - t end\r\n\treturn t\r\nend\r\n\r\nfunction SliderClass:Set(value, doTween)\r\n\tlocal spring = self._Spring\r\n\tlocal newT = math.clamp(value, 0, 1)\r\n\t\r\n\tif (self.Interval > 0) then\r\n\t\tnewT = math.floor((newT / self.Interval) + 0.5) * self.Interval\r\n\tend\r\n\t\r\n\tspring.t = newT\r\n\tspring.instant = not doTween\r\nend\r\n\r\nfunction SliderClass:Destroy()\r\n\tself._Maid:Sweep()\r\n\tself.Frame:Destroy()\r\n\tself.Changed = nil\r\n\tself.Clicked = nil\r\n\tself.StartDrag = nil\r\n\tself.StopDrag = nil\r\n\tself.Frame = nil\r\nend\r\n\r\n--\r\n\r\nreturn SliderClass"
h.Parent=b
local i=Instance.new"ModuleScript"
i.Name="TextMask"
i.Source="--[[\r\nClasses.TextMask\r\n\r\nThis class creates a text mask object which can be used to limit user input into a text gui element\r\n\r\nConstructors:\r\n\tnew(textFrame [instance])\r\n\t\t> Creates a text mask object for the given text frame.\r\n\r\nProperties:\r\n\tFrame [instance]\r\n\t\t> The text frame that you put as an argument when creating the text mask object.\r\n\r\nMethods:\r\n\t:GetValue() [variant]\r\n\t\t> Returns the text frame's value converted to the mask type.\r\n\t\t> For instance if you used a vector3 mask then this would return the value inputted as a vector3\r\n\t:GetMaskType() [string]\r\n\t\t> Returns the name of the mask type you are using\r\n\t:SetMaxLength(len [integer]) [void]\r\n\t\t> Sets the maximum number of characters the user can input into the text field\r\n\t\t> By default the max length is 230,000 characters\r\n\t:SetMaskType(name [string]) [void]\r\n\t\t> Sets mask type of the mask object. This name should coincide with a child of this module\r\n\t\t> By default the mask type is always set to \"String\"\r\n\t:Destroy() [void]\r\n\t\t> Destroys the mask object and any events, etc used in the purpose of running it.\r\n\r\n--]]\r\n\r\n-- CONSTANTS\r\n\r\nlocal GuiLib = script.Parent.Parent\r\nlocal Lazy = require(GuiLib:WaitForChild(\"LazyLoader\"))\r\nlocal Defaults = GuiLib:WaitForChild(\"Defaults\")\r\n\r\nlocal INCREMENT_BUTTON = Defaults:WaitForChild(\"IncrementButton\")\r\nlocal DECREMENT_BUTTON = Defaults:WaitForChild(\"DecrementButton\")\r\n\r\nlocal WARN_MSG = \"%s is not a valid mask. Defaulting to 'String' mask.\"\r\n\r\nlocal MASKS = {}\r\nfor _, module in pairs(script:GetChildren()) do\r\n\tMASKS[module.Name] = require(module)\r\nend\r\n\r\n-- Class\r\n\r\nlocal TextMaskClass = {}\r\nTextMaskClass.__index = TextMaskClass\r\nTextMaskClass.__type = \"TextMask\"\r\n\r\nfunction TextMaskClass:__tostring()\r\n\treturn TextMaskClass.__type\r\nend\r\n\r\n-- Public Constructors\r\n\r\nfunction TextMaskClass.new(textFrame)\r\n\tlocal self = setmetatable({}, TextMaskClass)\r\n\t\r\n\tself._Maid = Lazy.Utilities.Maid.new()\r\n\tself._MaskType = MASKS.String\r\n\tself._MaxLength = 230000\r\n\t\r\n\tself.Frame = textFrame\r\n\t\r\n\tinit(self)\r\n\t\r\n\treturn self\r\nend\r\n\r\n-- Private Methods\r\n\r\nfunction init(self)\r\n\tlocal frame = self.Frame\r\n\tlocal maid = self._Maid\r\n\r\n\tmaid:Mark(frame:GetPropertyChangedSignal(\"Text\"):Connect(function()\r\n\t\tlocal mask = self._MaskType\r\n\t\tlocal result = mask:Process(frame.Text):sub(1, self._MaxLength)\r\n\t\tframe.Text = result\r\n\tend))\r\n\t\r\n\tmaid:Mark(frame.FocusLost:Connect(function()\r\n\t\tlocal mask = self._MaskType\r\n\t\tif (not mask:Verify(frame.Text)) then\r\n\t\t\tframe.Text = mask.Default\r\n\t\tend\r\n\tend))\r\nend\r\n\r\n-- Public Methods\r\n\r\nfunction TextMaskClass:GetValue()\r\n\treturn self._MaskType:ToType(self.Frame.Text)\r\nend\r\n\r\nfunction TextMaskClass:GetMaskType()\r\n\treturn self._MaskType.Name\r\nend\r\n\r\nfunction TextMaskClass:SetMaxLength(len)\r\n\tself._MaxLength = len\r\nend\r\n\r\nfunction TextMaskClass:SetMaskType(name)\r\n\tlocal mask = MASKS[name]\r\n\tif (not mask) then\r\n\t\tmask = MASKS.String\r\n\t\twarn(WARN_MSG:format(name))\r\n\tend\r\n\tself._MaskType = mask\r\n\tself.Frame.Text = mask:Process(self.Frame.Text):sub(1, self._MaxLength)\r\n\t\r\n\t-- Add increment/decrement buttons for numeric inputs\r\n\tif name == \"Number\" then\r\n\t\t-- Initialize text to 0, consumer can override\r\n\t\tself.Frame.Text = 0\r\n\r\n\t\tself.IncrementButton = INCREMENT_BUTTON:Clone()\r\n\t\tself.IncrementButton.AnchorPoint = Vector2.new(1, 0)\r\n\t\tself.IncrementButton.Position = UDim2.new(1, 0, 0, 0)\r\n\t\tself._Maid:Mark(self.IncrementButton.Activated:Connect(function()\r\n\t\t\tself.Frame.Text = tonumber(self.Frame.Text) + 1\r\n\t\tend))\r\n\t\tself.IncrementButton.Parent = self.Frame\r\n\t\tself._Maid:Mark(self.IncrementButton)\r\n\t\t\r\n\t\tself.DecrementButton = DECREMENT_BUTTON:Clone()\r\n\t\tself.DecrementButton.AnchorPoint = Vector2.new(1, 1)\r\n\t\tself.DecrementButton.Position = UDim2.new(1, 0, 1, 0)\r\n\t\tself._Maid:Mark(self.DecrementButton.Activated:Connect(function()\r\n\t\t\tself.Frame.Text = tonumber(self.Frame.Text) - 1\r\n\t\tend))\r\n\t\tself.DecrementButton.Parent = self.Frame\r\n\t\tself._Maid:Mark(self.DecrementButton)\r\n\tend\r\nend\r\n\r\nfunction TextMaskClass:Destroy()\r\n\tself._Maid:Sweep()\r\nend\r\n\r\n--\r\n\r\nreturn TextMaskClass\r\n"
i.Parent=b
local j=Instance.new"ModuleScript"
j.Name="Integer"
j.Source="local NumberMask = require(script.Parent:WaitForChild(\"Number\"))\r\n\r\nlocal Mask = {}\r\n\r\nMask.Name = \"Integer\"\r\nMask.Default = \"0\"\r\n\r\nfunction Mask:Process(text)\r\n\tlocal new = NumberMask:Process(text)\r\n\tlocal find = new:find(\"%.\") or #new + 1\r\n\r\n\treturn new:sub(1, find - 1)\r\nend\r\n\r\nfunction Mask:Verify(text)\r\n\tlocal valid = NumberMask:Verify(text)\r\n\treturn (valid and not text:find(\"%.\"))\r\nend\r\n\r\nfunction Mask:ToType(text)\r\n\ttext = self:Verify(text) and text or self.Default\r\n\treturn tonumber(text)\r\nend\r\n\r\nreturn Mask"
j.Parent=i
local k=Instance.new"ModuleScript"
k.Name="Number"
k.Source="local Mask = {}\r\n\r\nMask.Name = \"Number\"\r\nMask.Default = \"0\"\r\n\r\nfunction Mask:Process(text)\r\n\tlocal new = text:gsub(\"[^%d.-]\", \"\")\r\n\t\r\n\tlocal neg = new:sub(1, 1)\r\n\tnew = neg .. new:sub(2):gsub(\"%-\", \"\")\r\n\t\r\n\tlocal found = new:find(\"%.\")\r\n\tif (found) then\r\n\t\tlocal a = new:sub(1, found)\r\n\t\tlocal b = new:sub(found + 1, #new):gsub(\"[%.]\", \"\")\r\n\t\treturn a .. b\r\n\tend\r\n\t\r\n\treturn new\r\nend\r\n\r\nfunction Mask:Verify(text)\r\n\tlocal find = text:find(\"[^%d.-]\") -- find any non number, decimal, negative\r\n\tif (not find) then\r\n\t\tif (text:sub(1, 1) == \"-\") then\r\n\t\t\tfind = text:sub(2):find(\"%-\")\r\n\t\t\tif (find or #text == 1) then\r\n\t\t\t\treturn false\r\n\t\t\tend\r\n\t\tend\r\n\t\t\r\n\t\tfind = text:find(\"%.\")\r\n\t\tif (find) then\r\n\t\t\tlocal new = text:sub(find + 1, #text):find(\"%.\") -- check for second decimal\r\n\t\t\treturn not new\r\n\t\tend\r\n\t\t\r\n\t\t-- Empty string is not a number\r\n\t\treturn text ~= \"\"\r\n\tend\r\n\treturn false\r\nend\r\n\r\nfunction Mask:ToType(text)\r\n\ttext = self:Verify(text) and text or self.Default\r\n\treturn tonumber(text)\r\nend\r\n\r\nreturn Mask"
k.Parent=i
local l=Instance.new"ModuleScript"
l.Name="String"
l.Source="local Mask = {}\r\n\r\nMask.Name = \"String\"\r\nMask.Default = \"\"\r\n\r\nfunction Mask:Process(text)\r\n\treturn text\r\nend\r\n\r\nfunction Mask:Verify(text)\r\n\treturn true\r\nend\r\n\r\nfunction Mask:ToType(text)\r\n\treturn text\r\nend\r\n\r\nreturn Mask"
l.Parent=i
local m=Instance.new"ModuleScript"
m.Name="Vector2"
m.Source="local NumberMask = require(script.Parent:WaitForChild(\"Number\"))\r\n\r\nlocal function matchArray(str, pattern)\r\n\tlocal arr = {}\r\n\tfor sub in string.gmatch(str, pattern) do\r\n\t\tarr[#arr + 1] = sub\r\n\tend\r\n\treturn arr\r\nend\r\n\r\nlocal Mask = {}\r\n\r\nMask.Name = \"Vector2\"\r\nMask.Default = \"0, 0\"\r\n\r\nfunction Mask:Process(text)\r\n\treturn text\r\nend\r\n\r\nfunction Mask:Verify(text)\r\n\tlocal find = text:find(\"[^%d., -]\") -- find any non number, decimal, comma, space or negative\r\n\tif (not find) then\r\n\t\tlocal nCommas = #string.split(text, \",\")\r\n\t\tif (nCommas == 2) then\r\n\t\t\tlocal nums = matchArray(text, \"%-*%d[%d.]*\")\r\n\t\t\tif (#nums == 2) then\r\n\t\t\t\tfor i, num in next, nums do\r\n\t\t\t\t\tif (not NumberMask:Verify(num)) then\r\n\t\t\t\t\t\treturn false\r\n\t\t\t\t\tend\r\n\t\t\t\tend\r\n\t\t\t\treturn true\r\n\t\t\tend\r\n\t\tend\r\n\tend\r\n\treturn false\r\nend\r\n\r\nfunction Mask:ToType(text)\r\n\ttext = self:Verify(text) and text or self.Default\r\n\t\r\n\tlocal components = string.split(text, \",\")\r\n\tfor i, c in next, components do\r\n\t\tcomponents[i] = tonumber(c)\r\n\tend\r\n\t\r\n\treturn Vector2.new(unpack(components))\r\nend\r\n\r\nreturn Mask"
m.Parent=i
local n=Instance.new"ModuleScript"
n.Name="Vector3"
n.Source="local NumberMask = require(script.Parent:WaitForChild(\"Number\"))\r\n\r\nlocal function matchArray(str, pattern)\r\n\tlocal arr = {}\r\n\tfor sub in string.gmatch(str, pattern) do\r\n\t\tarr[#arr + 1] = sub\r\n\tend\r\n\treturn arr\r\nend\r\n\r\nlocal Mask = {}\r\n\r\nMask.Name = \"Vector3\"\r\nMask.Default = \"0, 0, 0\"\r\n\r\nfunction Mask:Process(text)\r\n\treturn text\r\nend\r\n\r\nfunction Mask:Verify(text)\r\n\tlocal find = text:find(\"[^%d., -]\") -- find any non number, decimal, comma, space or negative\r\n\tif (not find) then\r\n\t\tlocal nCommas = #string.split(text, \",\")\r\n\t\tif (nCommas == 3) then\r\n\t\t\tlocal nums = matchArray(text, \"%-*%d[%d.]*\")\r\n\t\t\tif (#nums == 3) then\r\n\t\t\t\tfor i, num in next, nums do\r\n\t\t\t\t\tif (not NumberMask:Verify(num)) then\r\n\t\t\t\t\t\treturn false\r\n\t\t\t\t\tend\r\n\t\t\t\tend\r\n\t\t\t\treturn true\r\n\t\t\tend\r\n\t\tend\r\n\tend\r\n\treturn false\r\nend\r\n\r\nfunction Mask:ToType(text)\r\n\ttext = self:Verify(text) and text or self.Default\r\n\t\r\n\tlocal components = string.split(text, \",\")\r\n\tfor i, c in next, components do\r\n\t\tcomponents[i] = tonumber(c)\r\n\tend\r\n\t\r\n\treturn Vector3.new(unpack(components))\r\nend\r\n\r\nreturn Mask"
n.Parent=i
local o=Instance.new"ModuleScript"
o.Name="RadialMenu"
o.Source="--[[\r\nClasses.RadialMenu\r\n\r\nThis class creates a radial menu. It is by far the most \"raw\" module in this library as so much of how you interact with it is developer defined.\r\n\r\nConstructors:\r\n\tnew(subN [integer], tPercent [float], rotation [float])\r\n\t\t> Creates a radial menu divided into subN sections where the ring is tPercent width of the frame radius\r\n\t\t> and the ring is rotationally offset by rotation radians\r\n\r\nProperties:\r\n\tFrame [instance]\r\n\t\t> The container frame for the radial menu. Can be used for positioning and resizing.\r\n\t\t> Note that this frame should always be square, by default it's set to YY size constraining\r\n\tRotation [float]\r\n \t\t> The rotation offset that the developer entered as an argument when creating the radial menu.\r\n\tSubN [integer]\r\n\t\t> The number of subsections that the developer entered as an argument when creating the radial menu.\r\n\tEnabled [boolean]\r\n\t\t> Whether or not the radial menu is actively tracking input.\r\n\t\t> Defaults to true\r\n\tDeadZoneIn [float]\r\n\t\t> Number represents a percentage from the radius that will be ignored in regards to input\r\n\t\t> By default this is 0.5 meaning the center 50% of the radial frame ignores input\r\n\tDeadZoneOut [float]\r\n\t\t> Number represents a percentage from the radius that once passed will be ignored in regards to input.\r\n\t\t> By default this is math.huge meaning that as long as your outside of DeadZoneIn your input will not be ignored.\r\n\r\nMethods:\r\n\t:SetRadialProps(props [dictionary]) [void]\r\n\t\t> Sets the properties of all the radial background UI\r\n\t:SetDialProps(props [dictionary]) [void]\r\n\t\t> Sets the properties of the radial dial UI\r\n\t:GetTheta(userInputType [Enum.UserInputType]) [float]\r\n\t\t> Depending on if MouseMovement, Touch, or a Gamepad returns the directional angle that the user is inputting on their device\r\n\t\t> If input is not in deadzone range then this method returns nil\r\n\t\t> Returns the angle in radians\r\n\t:PickIndex(theta) [integer]\r\n\t\t> Given a directional angle returns the closest element on the radial wheel as an index.\r\n\t:GetRadial(index) [instance]\r\n\t\t> Returns the radial background UI for that index.\r\n\t:GetAttachment(index) [instance]\r\n\t\t> Returns the radial attachment UI for that index.\r\n\t\t> This frame is useful for putting text or images in.\r\n\t:IsVisible() [boolean]\r\n\t\t> Returns whether or not the radial menu is visible to the user or not.\r\n\t:Destroy() [void]\r\n\t\t> Destroys the RadioButtonGroup and all the events, etc that were running it.\r\n\r\nEvents:\r\n\t.Clicked:Connect(function(index [integer])\r\n\t\t> Fired when the user selects an element on the radial menu.\r\n\t.Hover:Connect(function(oldIndex [integer], newIndex [integer])\r\n\t\t> Fired when the user hovers in the direction of a new element on the radial menu\r\n--]]\r\n\r\n\r\n-- CONSTANTS\r\n\r\nlocal GuiLib = script.Parent.Parent\r\nlocal Lazy = require(GuiLib:WaitForChild(\"LazyLoader\"))\r\nlocal Defaults = GuiLib:WaitForChild(\"Defaults\")\r\n\r\nlocal UIS = game:GetService(\"UserInputService\")\r\nlocal RUNSERVICE = game:GetService(\"RunService\")\r\nlocal CONSTANTS = require(script:WaitForChild(\"CONSTANTS\"))\r\n\r\nlocal PI = math.pi\r\nlocal TAU = CONSTANTS.TAU\r\nlocal EX_OFFSET = CONSTANTS.EX_OFFSET\r\n\r\nlocal GAMEPAD_CLICK = {\r\n\t[Enum.KeyCode.ButtonA] = true\r\n}\r\n\r\nlocal MOUSE_GROUP = {\r\n\t[Enum.UserInputType.MouseButton1] = true,\r\n\t[Enum.UserInputType.MouseMovement] = true,\r\n\t[Enum.UserInputType.Touch] = true\r\n}\r\n\r\nlocal GAMEPAD_GROUP = {\r\n\t[Enum.UserInputType.Gamepad1] = true,\r\n\t[Enum.UserInputType.Gamepad2] = true,\r\n\t[Enum.UserInputType.Gamepad3] = true,\r\n\t[Enum.UserInputType.Gamepad4] = true,\r\n\t[Enum.UserInputType.Gamepad5] = true,\r\n\t[Enum.UserInputType.Gamepad6] = true,\r\n\t[Enum.UserInputType.Gamepad7] = true,\r\n\t[Enum.UserInputType.Gamepad8] = true\r\n}\r\n\r\nlocal CreateRadial = require(script:WaitForChild(\"CreateRadial\"))\r\n\r\n-- Class\r\n\r\nlocal RadialMenuClass = {}\r\nRadialMenuClass.__index = RadialMenuClass\r\nRadialMenuClass.__type = \"RadialMenu\"\r\n\r\nfunction RadialMenuClass:__tostring()\r\n\treturn RadialMenuClass.__type\r\nend\r\n\r\n-- Public Constructors\r\n\r\nfunction RadialMenuClass.new(subN, tPercent, rotation)\r\n\tlocal self = setmetatable({}, RadialMenuClass)\r\n\t\r\n\tself._Maid = Lazy.Utilities.Maid.new()\r\n\tself._ClickedBind = Instance.new(\"BindableEvent\")\r\n\tself._HoverBind = Instance.new(\"BindableEvent\")\r\n\tself._LastHoverIndex = nil\r\n\t\r\n\tself.Frame = CreateRadial(subN, tPercent, rotation)\r\n\tself.Rotation = rotation\r\n\tself.SubN = subN\r\n\t\r\n\tself.Enabled = true\r\n\tself.DeadZoneIn = 0.5\r\n\tself.DeadZoneOut = math.huge\r\n\t\r\n\tself.Clicked = self._ClickedBind.Event\r\n\tself.Hover = self._HoverBind.Event\r\n\t\r\n\tinit(self)\r\n\t\r\n\tself:SetDialProps{ImageColor3 = Color3.new(0, 0, 0)}\r\n\tself:SetRadialProps{\r\n\t\tImageColor3 = Color3.new(0, 0, 0),\r\n\t\tImageTransparency = 0.7\r\n\t}\r\n\t\r\n\treturn self\r\nend\r\n\r\n-- Private Methods\r\n\t\r\nlocal function shortestDist(start, stop)\r\n\tlocal modDiff = (stop - start) % TAU\r\n\tlocal sDist = PI - math.abs(math.abs(modDiff) - PI)\r\n\tif ((modDiff + TAU) % TAU < PI) then\r\n\t\treturn sDist\r\n\telse\r\n\t\treturn -sDist\r\n\tend\r\nend\r\n\r\nfunction init(self)\r\n\tlocal subN = self.SubN\r\n\tlocal dial = self.Frame.RadialDial\r\n\t\r\n\tlocal inputType = Enum.UserInputType.MouseMovement\r\n\t\r\n\tself._Maid:Mark(self._ClickedBind)\r\n\tself._Maid:Mark(self._HoverBind)\r\n\t\r\n\tself._Maid:Mark(UIS.LastInputTypeChanged:Connect(function(iType)\r\n\t\tif (MOUSE_GROUP[iType] or GAMEPAD_GROUP[iType]) then\r\n\t\t\tinputType = iType\r\n\t\tend\r\n\tend))\r\n\t\r\n\tlocal lTheta = 0\r\n\t\r\n\tself._Maid:Mark(UIS.InputBegan:Connect(function(input)\r\n\t\tif (not self.Enabled) then\r\n\t\t\treturn\r\n\t\tend\r\n\t\t\r\n\t\t\r\n\t\tif (GAMEPAD_GROUP[input.UserInputType]) then\r\n\t\t\tif (not GAMEPAD_CLICK[input.KeyCode]) then\r\n\t\t\t\treturn\r\n\t\t\telse\r\n\t\t\t\tself._ClickedBind:Fire(self:PickIndex(lTheta))\r\n\t\t\tend\r\n\t\tend\r\n\t\t\r\n\t\tlocal theta = self:GetTheta(input.UserInputType)\r\n\t\tif (theta) then\r\n\t\t\tself._ClickedBind:Fire(self:PickIndex(theta))\r\n\t\tend\r\n\tend))\r\n\r\n\tself._Maid:Mark(RUNSERVICE.RenderStepped:Connect(function(dt)\r\n\t\tif (not self.Enabled) then\r\n\t\t\treturn\r\n\t\tend\r\n\t\t\r\n\t\tlocal theta = self:GetTheta(inputType)\r\n\t\tif (theta and self:IsVisible()) then\r\n\t\t\tlTheta = theta\r\n\t\t\t\r\n\t\t\tlocal frameRot = math.rad(self.Frame.Rotation)\r\n\t\t\tlocal toDeg = math.deg(theta - self.Rotation + frameRot + EX_OFFSET + 2*TAU) % 360\r\n\t\t\tlocal closest = toDeg / (360 / self.SubN) + 0.5\r\n\t\t\t\r\n\t\t\tdial.Rotation = math.deg(self:GetRotation(closest))\r\n\t\t\t\r\n\t\t\tlocal index = self:PickIndex(theta)\r\n\t\t\tif (index ~= self._LastHoverIndex) then\r\n\t\t\t\tself._HoverBind:Fire(self._LastHoverIndex, index)\r\n\t\t\t\tself._LastHoverIndex = index\r\n\t\t\tend\r\n\t\tend\r\n\tend))\r\nend\r\n\r\n-- Public Methods\r\n\r\nfunction RadialMenuClass:SetRadialProps(props)\r\n\tfor _, child in next, self.Frame.Radial:GetChildren() do\r\n\t\tfor prop, value in next, props do\r\n\t\t\tchild[prop] = value\r\n\t\tend\r\n\tend\r\nend\r\n\r\nfunction RadialMenuClass:SetDialProps(props)\r\n\tlocal dial = self.Frame.RadialDial\r\n\tfor prop, value in next, props do\r\n\t\tdial[prop] = value\r\n\tend\r\nend\r\n\r\nfunction RadialMenuClass:GetTheta(userInputType)\r\n\tlocal delta = nil\r\n\t\r\n\tif (MOUSE_GROUP[userInputType]) then\r\n\t\tlocal frame = self.Frame\r\n\t\tlocal radius = frame.AbsoluteSize.y/2\r\n\t\tlocal center = frame.AbsolutePosition + frame.AbsoluteSize/2\r\n\t\tlocal mousePos = UIS:GetMouseLocation() + Vector2.new(0, -36)\r\n\t\tdelta = (mousePos - center) / radius\r\n\telseif (GAMEPAD_GROUP[userInputType]) then\r\n\t\tlocal states = UIS:GetGamepadState(userInputType)\r\n\t\tfor _, state in next, states do\r\n\t\t\tstates[state.KeyCode] = state\r\n\t\tend\r\n\t\tdelta = states[Enum.KeyCode.Thumbstick2].Position * Vector3.new(1, -1, 1)\r\n\tend\r\n\t\r\n\tif (delta) then\r\n\t\tlocal m = delta.Magnitude\r\n\t\tif (m >= self.DeadZoneIn and m <= self.DeadZoneOut) then\r\n\t\t\treturn math.atan2(delta.y, -delta.x)\r\n\t\tend\r\n\tend\r\nend\r\n\r\nfunction RadialMenuClass:PickIndex(theta)\r\n\tlocal frameRot = math.rad(self.Frame.Rotation)\r\n\tlocal toDeg = math.deg(theta - self.Rotation + frameRot + EX_OFFSET + 2*TAU) % 360\r\n\tlocal closest = math.floor(toDeg / (360 / self.SubN))\r\n\treturn closest + 1\r\nend\r\n\r\nfunction RadialMenuClass:GetRotation(index)\r\n\treturn -TAU * ((index - 1) / self.SubN)\r\nend\r\n\r\nfunction RadialMenuClass:GetRadial(index)\r\n\treturn self.Frame.Radial[index]\r\nend\r\n\r\nfunction RadialMenuClass:GetAttachment(index)\r\n\treturn self.Frame.Attach[index]\r\nend\r\n\r\nfunction RadialMenuClass:IsVisible()\r\n\tlocal frame = self.Frame\r\n\twhile (frame and frame:IsA(\"GuiObject\") and frame.Visible) do\r\n\t\tframe = frame.Parent\r\n\t\tif (frame and frame:IsA(\"ScreenGui\") and frame.Enabled) then\r\n\t\t\treturn true\r\n\t\tend\r\n\tend\r\n\treturn false\r\nend\r\n\r\nfunction RadialMenuClass:Destroy()\r\n\tself._Maid:Sweep()\r\n\tself.Frame:Destroy()\r\n\tself.Clicked = nil\r\n\tself.Hover = nil\r\n\tself.Frame = nil\r\nend\r\n\r\n--\r\n\r\nreturn RadialMenuClass"
o.Parent=b
local p=Instance.new"ModuleScript"
p.Name="CONSTANTS"
p.Source="TAU = math.pi*2\r\n\r\nGAP = 2\r\nFOV = 70\r\nVIEW_DIST = 50\r\nPART_PER_UNIT = 6\r\n\r\nCENTER = CFrame.new(0, 0, -VIEW_DIST)\r\nEXTERIOR_RADIUS = VIEW_DIST * math.tan(math.rad(FOV/2))\r\nG_OFFSET = GAP / (2*EXTERIOR_RADIUS)\r\nEX_OFFSET = -TAU/4 + G_OFFSET\r\n\r\nlocal module = getfenv()\r\nmodule.script = nil\r\nreturn module"
p.Parent=o
local q=Instance.new"ModuleScript"
q.Name="CreateRadial"
q.Source="-- CONSTANTS\r\n\r\nlocal CONSTANTS = require(script.Parent:WaitForChild(\"CONSTANTS\"))\r\nlocal Triangle = require(script.Parent:WaitForChild(\"Triangle\"))\r\n\r\nlocal PI2 = math.pi/2\r\nlocal TAU = CONSTANTS.TAU\r\n\r\nlocal GAP = CONSTANTS.GAP\r\nlocal PART_PER_UNIT = CONSTANTS.PART_PER_UNIT\r\n\r\nlocal CENTER = CONSTANTS.CENTER\r\nlocal EXTERIOR_RADIUS = CONSTANTS.EXTERIOR_RADIUS\r\nlocal EX_OFFSET = CONSTANTS.EX_OFFSET\r\nlocal G_OFFSET = CONSTANTS.G_OFFSET\r\n\r\nlocal VPF = Instance.new(\"ViewportFrame\")\r\nVPF.Ambient = Color3.new(1, 1, 1)\r\nVPF.LightColor = Color3.new(1, 1, 1)\r\nVPF.LightDirection = Vector3.new(0, 0, -1)\r\nVPF.BackgroundTransparency = 1\r\nVPF.Size = UDim2.new(1, 0, 1, 0)\r\n\r\nlocal CAMERA = Instance.new(\"Camera\")\r\nCAMERA.CameraType = Enum.CameraType.Scriptable\r\nCAMERA.CFrame = CFrame.new()\r\nCAMERA.FieldOfView = CONSTANTS.FOV\r\n\r\n--\r\n\r\nlocal function pivotAround(model, pivotCF, newCF)\r\n\tlocal invPivotCF = pivotCF:Inverse()\r\n\tfor _, part in next, model:GetDescendants() do\r\n\t\tpart.CFrame = newCF * (invPivotCF * part.CFrame)\r\n\tend\r\nend\r\n\r\nlocal function createSection(subN, interior_radius, exterior_radius, ppu)\r\n\tlocal subModel = Instance.new(\"Model\")\r\n\t\r\n\tlocal exCircum = (TAU*exterior_radius)/subN - GAP\r\n\tlocal inCircum = (TAU*interior_radius)/subN - GAP\r\n\r\n\tlocal exTheta = exCircum / (exterior_radius)\r\n\tlocal inTheta = inCircum / (interior_radius)\r\n\tlocal diffTheta = exTheta - inTheta\r\n\t\r\n\tlocal exPoints = {}\r\n\tlocal inPoints = {}\r\n\t\r\n\tlocal nParts = math.ceil(exCircum/ppu)\r\n\t\r\n\tfor i = 0, nParts do\r\n\t\texPoints[i + 1] = CENTER * CFrame.fromEulerAnglesXYZ(0, 0, (i/nParts)*exTheta) * Vector3.new(exterior_radius, 0, 0)\r\n\t\tinPoints[i + 1] = CENTER * CFrame.fromEulerAnglesXYZ(0, 0, diffTheta/2 + (i/nParts)*inTheta) * Vector3.new(interior_radius, 0, 0)\r\n\tend\r\n\t\r\n\tfor i = 1, nParts do\r\n\t\tlocal a = exPoints[i]\r\n\t\tlocal b = inPoints[i]\r\n\t\tlocal c = exPoints[i + 1]\r\n\t\tlocal d = inPoints[i + 1]\r\n\t\t\r\n\t\tTriangle(subModel, a, b, c)\r\n\t\tTriangle(subModel, b, c, d)\r\n\tend\r\n\t\r\n\treturn subModel\r\nend\r\n\r\nlocal function createRadial(subN, tPercent, rotation)\r\n\trotation = rotation or 0\r\n\t\r\n\tlocal dialEx = (1 - tPercent)*EXTERIOR_RADIUS - 1\r\n\tlocal dialIn = dialEx - 2\r\n\t\r\n\tlocal section = createSection(subN, (1 - tPercent)*EXTERIOR_RADIUS, EXTERIOR_RADIUS, PART_PER_UNIT)\r\n\tlocal innerSection = createSection(subN, dialIn, dialEx, PART_PER_UNIT/2)\r\n\t\r\n\tlocal frame = Instance.new(\"Frame\")\r\n\tlocal radialFrame = Instance.new(\"Frame\")\r\n\tlocal attachFrame = Instance.new(\"Frame\")\r\n\tradialFrame.BackgroundTransparency = 1\r\n\tattachFrame.BackgroundTransparency = 1\r\n\tradialFrame.Size = UDim2.new(1, 0, 1, 0)\r\n\tattachFrame.Size = UDim2.new(1, 0, 1, 0)\r\n\tradialFrame.Name = \"Radial\"\r\n\tattachFrame.Name = \"Attach\"\r\n\tradialFrame.Parent = frame\r\n\tattachFrame.Parent = frame\r\n\t\r\n\tlocal thickness = tPercent * EXTERIOR_RADIUS\r\n\tlocal interior_radius = EXTERIOR_RADIUS - thickness\r\n\tlocal inv_tPercent = 1 - tPercent/2\r\n\t\r\n\tlocal exCircum = (TAU*EXTERIOR_RADIUS)/subN\r\n\tlocal exTheta = exCircum / EXTERIOR_RADIUS\r\n\tlocal inCircum = (TAU*interior_radius)/subN - GAP\r\n\tlocal inTheta = inCircum / (interior_radius)\r\n\t\r\n\tlocal edge = Vector2.new(math.cos(inTheta), math.sin(inTheta))*interior_radius - Vector2.new(interior_radius, 0)\r\n\tlocal edgeLen = math.min(edge.Magnitude / (EXTERIOR_RADIUS*2), 0.18)\r\n\t\r\n\tfor i = 0, subN - 1 do\r\n\t\tlocal vpf = VPF:Clone()\r\n\t\tlocal cam = CAMERA:Clone()\r\n\t\tvpf.CurrentCamera = cam\r\n\t\tvpf.Name = i + 1\r\n\t\t\r\n\t\tlocal theta = (i/subN)*TAU + rotation\r\n\t\t\r\n\t\tlocal sub = section:Clone()\r\n\t\tpivotAround(sub, CENTER, CENTER * CFrame.fromEulerAnglesXYZ(0, 0, theta + EX_OFFSET))\r\n\t\tsub.Parent = vpf\r\n\t\t\r\n\t\tlocal t = theta - EX_OFFSET + exTheta/2 + G_OFFSET\r\n\t\tlocal c = -math.cos(t)/2 * inv_tPercent\r\n\t\tlocal s = math.sin(t)/2 * inv_tPercent\r\n\t\t\r\n\t\tlocal attach = Instance.new(\"Frame\")\r\n\t\tattach.Name = i + 1\r\n\t\tattach.BackgroundTransparency = 1\r\n\t\tattach.BackgroundColor3 = Color3.new()\r\n\t\tattach.BorderSizePixel = 0\r\n\t\tattach.AnchorPoint = Vector2.new(0.5, 0.5)\r\n\t\tattach.Position = UDim2.new(0.5 + c, 0, 0.5 + s, 0)\r\n\t\tattach.Size = UDim2.new(edgeLen, 0, edgeLen, 0)\r\n\t\tattach.Parent = attachFrame\r\n\t\t\r\n\t\tcam.Parent = vpf\r\n\t\tvpf.Parent = radialFrame\r\n\tend\r\n\t\r\n\tsection:Destroy()\r\n\t\r\n\tlocal vpf = VPF:Clone()\r\n\tlocal cam = CAMERA:Clone()\r\n\tvpf.CurrentCamera = cam\r\n\tvpf.Name = \"RadialDial\"\r\n\t\r\n\tlocal g = GAP / (2*dialEx)\r\n\tlocal off = -TAU/4 + g\r\n\t\r\n\tpivotAround(innerSection, CENTER, CENTER * CFrame.fromEulerAnglesXYZ(0, 0, rotation + off))\r\n\tinnerSection.Parent = vpf\r\n\tvpf.Parent = frame\r\n\t\r\n\tframe.BackgroundTransparency = 1\r\n\tframe.SizeConstraint = Enum.SizeConstraint.RelativeYY\r\n\tframe.Size = UDim2.new(1, 0, 1, 0)\r\n\treturn frame\r\nend\r\n\r\n--\r\n\r\nreturn createRadial"
q.Parent=o
local r=Instance.new"ModuleScript"
r.Name="Triangle"
r.Source="local WEDGE = Instance.new(\"WedgePart\")\r\nWEDGE.Material = Enum.Material.SmoothPlastic\r\nWEDGE.Anchored = true\r\nWEDGE.CanCollide = false\r\nWEDGE.Color = Color3.new(1, 1, 1)\r\n\r\nreturn function(parent, a, b, c)\r\n\tlocal ab, ac, bc = b - a, c - a, c - b\r\n\tlocal abd, acd, bcd = ab:Dot(ab), ac:Dot(ac), bc:Dot(bc)\r\n\t\r\n\tif (abd > acd and abd > bcd) then\r\n\t\tc, a = a, c\r\n\telseif (acd > bcd and acd > abd) then\r\n\t\ta, b = b, a\r\n\tend\r\n\t\r\n\tab, ac, bc = b - a, c - a, c - b\r\n\t\r\n\tlocal right = ac:Cross(ab).Unit\r\n\tlocal up = bc:Cross(right).Unit\r\n\tlocal back = bc.Unit\r\n\t\r\n\tlocal height = math.abs(ab:Dot(up))\r\n\tlocal width1 = math.abs(ab:Dot(back))\r\n\tlocal width2 = math.abs(ac:Dot(back))\r\n\t\r\n\tlocal w1 = WEDGE:Clone()\r\n\tw1.Size = Vector3.new(0, height, width1)\r\n\tw1.CFrame = CFrame.fromMatrix((a + b)/2, right, up, back)\r\n\tw1.Parent = parent\r\n\t\r\n\tlocal w2 = WEDGE:Clone()\r\n\tw2.Size = Vector3.new(0, height, width2)\r\n\tw2.CFrame = CFrame.fromMatrix((a + c)/2, -right, up, -back)\r\n\tw2.Parent = parent\r\n\t\r\n\treturn w1, w2\r\nend"
r.Parent=o
local s=Instance.new"Folder"
s.Name="Constructors"
s.Parent=a
local t=Instance.new"ModuleScript"
t.Name="List"
t.Source="--[[\r\nConstructors.List\r\n\r\nThis module provides a set of functions useful for generating lists that can be scrolled through.\r\n\r\nThis module only has one function:\r\n\r\nList.Create(\r\n\tstring[] list, -- an array of strings used to generate instances for the list\r\n\tinteger scrollMax, -- the maximum number of elements visible in the scroll frame at any given time. Defaults to math.huge\r\n\tenum fillDirection, -- Enum.FillDirection lets you decide if the list is vertical or horizontal. Defaults to verical\r\n\tudim padding, -- scale and offset for padding between instances. Defaults to no padding\r\n\tfunction instanceFunc -- must return a UI object such as a frame. Defaults to creating a textbutton with a child textlabel\r\n)\r\n\r\n--]]\r\n\r\n-- CONSTANTS\r\n\r\nlocal GuiLib = script.Parent.Parent\r\nlocal Lazy = require(GuiLib:WaitForChild(\"LazyLoader\"))\r\nlocal Defaults = GuiLib:WaitForChild(\"Defaults\")\r\n\r\nlocal LIST_BUTTON = Defaults:WaitForChild(\"ListButton\")\r\n\r\nlocal DEFAULT_LAYOUT = {\r\n\tSortOrder = Enum.SortOrder.LayoutOrder\r\n}\r\n\r\n-- Private Functions\r\n\r\nlocal function defaultButton(index, option)\r\n\tlocal button = LIST_BUTTON:Clone()\r\n\tbutton.Name = option .. \"_button\"\r\n\tbutton.Label.Text = option\r\n\treturn button\r\nend\r\n\r\n-- Library\r\n\r\nlocal List = {}\r\n\r\nfunction List.Create(list, max, fillDirection, padding, instanceFunc)\r\n\tmax = max or math.huge\r\n\tpadding = padding or UDim.new(0, 0)\r\n\tfillDirection = fillDirection or Enum.FillDirection.Vertical\r\n\tinstanceFunc = instanceFunc or defaultButton\r\n\r\n\tlocal nList = #list\r\n\tlocal dList = 1 / nList\r\n\t\r\n\tlocal isVertical = (fillDirection == Enum.FillDirection.Vertical)\r\n\t\r\n\tlocal listFrame = Instance.new(\"Frame\")\r\n\tlistFrame.Name = \"ListFrame\"\r\n\tlistFrame.BorderSizePixel = 0 \r\n\t\r\n\tlocal scrollFrame = Instance.new(\"ScrollingFrame\")\r\n\tscrollFrame.Name = \"ScrollFrame\"\r\n\tscrollFrame.BackgroundTransparency = 1\r\n\tscrollFrame.BorderSizePixel = 0\r\n\tscrollFrame.Size = UDim2.new(1, 0, 1, 0)\r\n\t\r\n\tlocal canvasSize = nil\t\r\n\tlocal elementSize = nil\r\n\tlocal extraPosition = nil\r\n\t\r\n\tlocal adj = (nList - 1) / nList\r\n\tlocal scale = padding.Scale * adj\r\n\tlocal offset = padding.Offset * adj\r\n\t\r\n\tif (isVertical) then\r\n\t\tcanvasSize = UDim2.new(0, 0, nList / max, 0) \r\n\t\telementSize = UDim2.new(1, 0, dList - scale, -offset)\r\n\telse\r\n\t\tcanvasSize = UDim2.new(nList / max , 0, 0, 0)\r\n\t\telementSize = UDim2.new(dList - scale, -offset, 1, 0)\r\n\tend\r\n\t\r\n\tscrollFrame.CanvasSize = canvasSize\r\n\t\r\n\tlocal items = {}\r\n\tfor i, option in ipairs(list) do\r\n\t\tlocal item = instanceFunc(i, option)\r\n\t\titem.LayoutOrder = i\r\n\t\titem.Size = elementSize\r\n\t\titem.Position = UDim2.new(0, 0, (i-1)*dList, 0)\r\n\t\t\r\n\t\tif (isVertical) then\r\n\t\t\titem.Position = item.Position + UDim2.new(0, 0, padding.Scale/nList*(i-1), padding.Offset/nList*(i-1))\r\n\t\telse\r\n\t\t\titem.Position = item.Position + UDim2.new(padding.Scale/nList*(i-1), padding.Offset/nList*(i-1), 0, 0)\r\n\t\tend\r\n\t\t\r\n\t\titems[i] = item\r\n\t\titem.Parent = scrollFrame\r\n\tend\r\n\t\r\n\tlistFrame.BackgroundTransparency = items[1].BackgroundTransparency\r\n\tlistFrame.BackgroundColor3 = items[1].BackgroundColor3\r\n\tscrollFrame.Parent = listFrame\r\n\t\r\n\treturn listFrame\t\r\nend\r\n\r\n--\r\n\r\nreturn List"
t.Parent=s
local u=Instance.new"Folder"
u.Name="Utilities"
u.Parent=a
local v=Instance.new"ModuleScript"
v.Name="Maid"
v.Source="-- CONSTANTS\r\n\r\nlocal FORMAT_STR = \"Maid does not support type \\\"%s\\\"\"\r\n\r\nlocal DESTRUCTORS = {\r\n\t[\"function\"] = function(item)\r\n\t\titem()\r\n\tend;\r\n\t[\"RBXScriptConnection\"] = function(item)\r\n\t\titem:Disconnect()\r\n\tend;\r\n\t[\"Instance\"] = function(item)\r\n\t\titem:Destroy()\r\n\tend;\r\n}\r\n\r\n-- Class\r\n\r\nlocal MaidClass = {}\r\nMaidClass.__index = MaidClass\r\nMaidClass.__type = \"Maid\"\r\n\r\nfunction MaidClass:__tostring()\r\n\treturn MaidClass.__type\r\nend\r\n\r\n-- Public Constructors\r\n\r\nfunction MaidClass.new()\r\n\tlocal self = setmetatable({}, MaidClass)\r\n\t\r\n\tself.Trash = {}\r\n\t\r\n\treturn self\r\nend\r\n\r\n-- Public Methods\r\n\r\nfunction MaidClass:Mark(item)\r\n\tlocal tof = typeof(item)\r\n\t\r\n\tif (DESTRUCTORS[tof]) then\r\n\t\tself.Trash[item] = tof\r\n\telse\r\n\t\terror(FORMAT_STR:format(tof), 2)\r\n\tend\r\nend\r\n\r\nfunction MaidClass:Unmark(item)\r\n\tif (item) then\r\n\t\tself.Trash[item] = nil\r\n\telse\r\n\t\tself.Trash = {}\r\n\tend\r\nend\r\n\r\nfunction MaidClass:Sweep()\r\n\tfor item, tof in next, self.Trash do\r\n\t\tDESTRUCTORS[tof](item)\r\n\tend\r\n\tself.Trash = {}\r\nend\r\n\r\n--\r\n\r\nreturn MaidClass"
v.Parent=u
local w=Instance.new"ModuleScript"
w.Name="Spring"
w.Source="-- CONSTANTS\r\n\r\n-- Private Functions\r\n\r\nlocal function getAbsDist(a, b)\r\n\tlocal d = b - a\r\n\tif (type(d) == \"number\") then\r\n\t\treturn math.abs(d)\r\n\tend\r\n\treturn d.Magnitude\r\nend\r\n\r\n-- Class\r\n\r\nlocal SpringClass = {}\r\nSpringClass.__index = SpringClass\r\nSpringClass.__type = \"Spring\"\r\n\r\nfunction SpringClass:__tostring()\r\n\treturn SpringClass.__type\r\nend\r\n\r\n-- Public Constructors\r\n\r\nfunction SpringClass.new(stiffness, dampingCoeff, dampingRatio, initialPos)\r\n\tlocal self = setmetatable({}, SpringClass)\r\n\t\r\n\tself.instant = false\r\n\tself.marginOfError = 1E-6\r\n\r\n\tdampingRatio = dampingRatio or 1\r\n\tlocal m = dampingCoeff*dampingCoeff/(4*stiffness*dampingRatio*dampingRatio)\r\n\tself.k = stiffness/m\r\n\tself.d = -dampingCoeff/m\r\n\tself.x = initialPos\r\n\tself.t = initialPos\r\n\tself.v = initialPos*0\r\n\r\n\treturn self\r\nend\r\n\r\n-- Public Methods\r\n\r\nfunction SpringClass:Update(dt)\r\n\tif (not self.instant) then\r\n\t\tlocal t, k, d, x0, v0 = self.t, self.k, self.d, self.x, self.v\r\n\t\tlocal a0 = k*(t - x0) + v0*d\r\n\t\tlocal v1 = v0 + a0*(dt/2)\r\n\t\tlocal a1 = k*(t - (x0 + v0*(dt/2))) + v1*d\r\n\t\tlocal v2 = v0 + a1*(dt/2)\r\n\t\tlocal a2 = k*(t - (x0 + v1*(dt/2))) + v2*d\r\n\t\tlocal v3 = v0 + a2*dt\r\n\t\tlocal x4 = x0 + (v0 + 2*(v1 + v2) + v3)*(dt/6)\r\n\t\tself.x, self.v = x4, v0 + (a0 + 2*(a1 + a2) + k*(t - (x0 + v2*dt)) + v3*d)*(dt/6)\r\n\t\t\r\n\t\tif (getAbsDist(x4, self.t) > self.marginOfError) then\r\n\t\t\treturn x4\r\n\t\tend\r\n\tend\r\n\t\r\n\tself.x, self.v = self.t, self.v*0\r\n\treturn self.x\r\nend\r\n\r\n--\r\n\r\nreturn SpringClass"
w.Parent=u
local x=Instance.new"ScreenGui"
x.Name="Defaults"
x.ZIndexBehavior=1
x.Parent=a
local y=Instance.new"TextButton"
y.Name="ListButton"
y.Size=UDim2.new(0,100,0,35)
y.Position=UDim2.new(0,10,0,10)
y.BorderSizePixel=0
y.BackgroundColor3=Color3.fromRGB(29,29,30)
y.FontSize=5
y.TextSize=14
y.TextColor3=Color3.fromRGB(255,255,255)
y.Text=""
y.Font=17
y.Parent=x
local z=Instance.new"TextLabel"
z.Name="Label"
z.AnchorPoint=Vector2.new(0.5,0.5)
z.Size=UDim2.new(1,-20,1,0)
z.ClipsDescendants=true
z.BackgroundTransparency=1
z.Position=UDim2.new(0.5,0,0.5,0)
z.BackgroundColor3=Color3.fromRGB(255,255,255)
z.FontSize=5
z.TextTruncate=1
z.TextSize=14
z.TextColor3=Color3.fromRGB(255,255,255)
z.Font=17
z.TextXAlignment=0
z.Parent=y
local A=Instance.new"Frame"
A.Name="CheckboxLabel"
A.Size=UDim2.new(0,300,0,24)
A.ClipsDescendants=true
A.BackgroundTransparency=1
A.Position=UDim2.new(0,200,0,10)
A.BorderSizePixel=0
A.BackgroundColor3=Color3.fromRGB(29,29,30)
A.Parent=x
local B=Instance.new"TextLabel"
B.Name="Label"
B.LayoutOrder=1
B.Size=UDim2.new(0.92,-10,1,0)
B.BackgroundTransparency=1
B.Position=UDim2.new(0.08,10,0,0)
B.BackgroundColor3=Color3.fromRGB(255,255,255)
B.FontSize=5
B.TextTruncate=1
B.TextSize=14
B.TextColor3=Color3.fromRGB(255,255,255)
B.Text="Hello world my name is"
B.Font=17
B.TextXAlignment=0
B.Parent=A
local C=Instance.new"Frame"
C.Name="CheckContainer"
C.Size=UDim2.new(0.08,0,1,0)
C.BorderColor3=Color3.fromRGB(33,95,222)
C.BackgroundTransparency=1
C.BackgroundColor3=Color3.fromRGB(47,47,48)
C.Parent=A
local D=Instance.new"TextButton"
D.Name="CheckButton"
D.Selectable=false
D.AnchorPoint=Vector2.new(0.5,0.5)
D.Size=UDim2.new(1,-4,1,-4)
D.BorderColor3=Color3.fromRGB(255,255,255)
D.Position=UDim2.new(0.5,0,0.5,0)
D.BorderSizePixel=0
D.BackgroundColor3=Color3.fromRGB(47,47,48)
D.AutoButtonColor=false
D.Text=""
D.Parent=C
local E=Instance.new"ImageLabel"
E.Name="Checkmark"
E.AnchorPoint=Vector2.new(0.5,0.5)
E.Visible=false
E.Size=UDim2.new(1.3,0,1.3,0)
E.BackgroundTransparency=1
E.Position=UDim2.new(0.5,0,0.5,0)
E.BorderSizePixel=0
E.BackgroundColor3=Color3.fromRGB(33,95,222)
E.Image="rbxassetid://5422477875"
E.Parent=D
local F=Instance.new"Frame"
F.Name="Outline"
F.Size=UDim2.new(1,0,1,0)
F.BorderColor3=Color3.fromRGB(255,255,255)
F.BackgroundTransparency=1
F.BackgroundColor3=Color3.fromRGB(255,255,255)
F.Parent=C
local G=Instance.new"Frame"
G.Size=UDim2.new(1,0,0,2)
G.BorderSizePixel=0
G.BackgroundColor3=Color3.fromRGB(255,255,255)
G.Parent=F
local H=Instance.new"Frame"
H.AnchorPoint=Vector2.new(0,1)
H.Size=UDim2.new(1,0,0,2)
H.Position=UDim2.new(0,0,1,0)
H.BorderSizePixel=0
H.BackgroundColor3=Color3.fromRGB(255,255,255)
H.Parent=F
local I=Instance.new"Frame"
I.Size=UDim2.new(0,2,1,0)
I.BorderSizePixel=0
I.BackgroundColor3=Color3.fromRGB(255,255,255)
I.Parent=F
local J=Instance.new"Frame"
J.AnchorPoint=Vector2.new(1,0)
J.Size=UDim2.new(0,2,1,0)
J.Position=UDim2.new(1,0,0,0)
J.BorderSizePixel=0
J.BackgroundColor3=Color3.fromRGB(255,255,255)
J.Parent=F
local K=Instance.new"Frame"
K.Name="RadioButtonLabel"
K.Size=UDim2.new(0,300,0,24)
K.BorderColor3=Color3.fromRGB(33,95,222)
K.BackgroundTransparency=1
K.Position=UDim2.new(0,200,0,60)
K.BorderSizePixel=0
K.BackgroundColor3=Color3.fromRGB(29,29,30)
K.Parent=x
local L=Instance.new"TextLabel"
L.Name="Label"
L.LayoutOrder=1
L.Size=UDim2.new(0.92,-10,1,0)
L.ClipsDescendants=true
L.BackgroundTransparency=1
L.Position=UDim2.new(0.08,10,0,0)
L.BackgroundColor3=Color3.fromRGB(255,255,255)
L.FontSize=5
L.TextTruncate=1
L.TextSize=14
L.TextColor3=Color3.fromRGB(255,255,255)
L.Text="Hello world my name is bob"
L.Font=17
L.TextXAlignment=0
L.Parent=K
local M=Instance.new"Frame"
M.Name="RadioContainer"
M.Size=UDim2.new(0.08,0,1,0)
M.BorderColor3=Color3.fromRGB(33,95,222)
M.BackgroundTransparency=1
M.BackgroundColor3=Color3.fromRGB(255,255,255)
M.Parent=K
local N=Instance.new"ImageLabel"
N.Name="Outline"
N.AnchorPoint=Vector2.new(1,1)
N.ZIndex=0
N.Size=UDim2.new(1,0,1,0)
N.BorderColor3=Color3.fromRGB(255,255,255)
N.BackgroundTransparency=1
N.Position=UDim2.new(1,0,1,0)
N.BackgroundColor3=Color3.fromRGB(255,255,255)
N.Image="rbxassetid://4504304159"
N.Parent=M
local O=Instance.new"ImageButton"
O.Name="RadioButton"
O.Selectable=false
O.AnchorPoint=Vector2.new(0.5,0.5)
O.Size=UDim2.new(1,-4,1,-4)
O.BorderColor3=Color3.fromRGB(255,255,255)
O.BackgroundTransparency=1
O.Position=UDim2.new(0.5,0,0.5,0)
O.BorderSizePixel=0
O.BackgroundColor3=Color3.fromRGB(47,47,48)
O.AutoButtonColor=false
O.ImageColor3=Color3.fromRGB(47,47,48)
O.Image="rbxassetid://4504304159"
O.Parent=M
local P=Instance.new"ImageLabel"
P.Name="Circle"
P.AnchorPoint=Vector2.new(0.5,0.5)
P.Size=UDim2.new(1,-6,1,-6)
P.BackgroundTransparency=1
P.Position=UDim2.new(0.5,0,0.5,0)
P.BorderSizePixel=0
P.BackgroundColor3=Color3.fromRGB(33,95,222)
P.Image="rbxassetid://4504304159"
P.ImageColor3=Color3.fromRGB(33,95,222)
P.Parent=O
local Q=Instance.new"Frame"
Q.Name="SliderFrameY"
Q.Size=UDim2.new(0,20,0,300)
Q.BackgroundTransparency=1
Q.Position=UDim2.new(0,50,0,250)
Q.BorderSizePixel=0
Q.BackgroundColor3=Color3.fromRGB(29,29,30)
Q.Parent=x
local R=Instance.new"Frame"
R.Name="Background"
R.AnchorPoint=Vector2.new(0.5,0.5)
R.Size=UDim2.new(1,0,1,0)
R.BackgroundTransparency=1
R.Position=UDim2.new(0.5,0,0.5,0)
R.BackgroundColor3=Color3.fromRGB(255,255,255)
R.Parent=Q
local S=Instance.new"Frame"
S.Name="Bar"
S.LayoutOrder=1
S.AnchorPoint=Vector2.new(0.5,0.5)
S.Size=UDim2.new(0.125,0,1,0)
S.Position=UDim2.new(0.5,0,0.5,0)
S.BorderSizePixel=0
S.BackgroundColor3=Color3.fromRGB(17,154,222)
S.Parent=R
local T=Instance.new"ImageLabel"
T.Name="Dragger"
T.Selectable=true
T.AnchorPoint=Vector2.new(0.5,0.5)
T.ZIndex=4
T.Size=UDim2.new(0.5,0,0.5,0)
T.SizeConstraint=1
T.BackgroundTransparency=1
T.Position=UDim2.new(0.5,0,0.5,0)
T.Active=true
T.BackgroundColor3=Color3.fromRGB(255,255,255)
T.Image="rbxassetid://4504304159"
T.ImageColor3=Color3.fromRGB(33,95,222)
T.Parent=Q
local U=Instance.new"Frame"
U.Name="SliderFrameX"
U.Size=UDim2.new(0,300,0,20)
U.BackgroundTransparency=1
U.Position=UDim2.new(0,50,0,200)
U.BorderSizePixel=0
U.BackgroundColor3=Color3.fromRGB(29,29,30)
U.Parent=x
local V=Instance.new"Frame"
V.Name="Background"
V.AnchorPoint=Vector2.new(0.5,0.5)
V.Size=UDim2.new(1,0,1,0)
V.BackgroundTransparency=1
V.Position=UDim2.new(0.5,0,0.5,0)
V.BackgroundColor3=Color3.fromRGB(255,255,255)
V.Parent=U
local W=Instance.new"Frame"
W.Name="Bar"
W.LayoutOrder=1
W.AnchorPoint=Vector2.new(0.5,0.5)
W.Size=UDim2.new(1,0,0.125,0)
W.Position=UDim2.new(0.5,0,0.5,0)
W.BorderSizePixel=0
W.BackgroundColor3=Color3.fromRGB(17,154,222)
W.Parent=V
local X=Instance.new"ImageLabel"
X.Name="Dragger"
X.Selectable=true
X.AnchorPoint=Vector2.new(0.5,0.5)
X.ZIndex=4
X.Size=UDim2.new(0.5,0,0.5,0)
X.SizeConstraint=2
X.BackgroundTransparency=1
X.Position=UDim2.new(0.5,0,0.5,0)
X.Active=true
X.BackgroundColor3=Color3.fromRGB(255,255,255)
X.Image="rbxassetid://4504304159"
X.ImageColor3=Color3.fromRGB(33,95,222)
X.Parent=U
local Y=Instance.new"TextButton"
Y.Name="DropdownButton"
Y.ZIndex=2
Y.Size=UDim2.new(0,100,0,35)
Y.Position=UDim2.new(0,10,0,60)
Y.BorderSizePixel=0
Y.BackgroundColor3=Color3.fromRGB(29,29,30)
Y.FontSize=5
Y.TextSize=14
Y.TextColor3=Color3.fromRGB(255,255,255)
Y.Text=""
Y.Font=3
Y.Parent=x
local Za=Instance.new"TextLabel"
Za.Name="Option"
Za.AnchorPoint=Vector2.new(0,0.5)
Za.Size=UDim2.new(0.65,-12,1,0)
Za.ClipsDescendants=true
Za.BackgroundTransparency=1
Za.Position=UDim2.new(0,12,0.5,0)
Za.BackgroundColor3=Color3.fromRGB(255,255,255)
Za.FontSize=5
Za.TextTruncate=1
Za.TextSize=14
Za.TextColor3=Color3.fromRGB(255,255,255)
Za.Text="1"
Za.Font=17
Za.TextXAlignment=0
Za.Parent=Y
local aa=Instance.new"ImageLabel"
aa.Name="Arrow"
aa.AnchorPoint=Vector2.new(1,0.5)
aa.Size=UDim2.new(0.35,0,1,0)
aa.BackgroundTransparency=1
aa.Position=UDim2.new(1,0,0.5,0)
aa.BackgroundColor3=Color3.fromRGB(255,255,255)
aa.Image="rbxassetid://5143165549"
aa.Parent=Y
local ba=Instance.new"Frame"
ba.Name="Background"
ba.ZIndex=0
ba.Size=UDim2.new(1,0,1,0)
ba.BackgroundColor3=Color3.fromRGB(47,47,48)
ba.Parent=x
local ca=Instance.new"TextButton"
ca.Name="IncrementButton"
ca.ZIndex=2
ca.Size=UDim2.new(1,0,0.5,0)
ca.Position=UDim2.new(0,10,0,60)
ca.BorderSizePixel=0
ca.BackgroundColor3=Color3.fromRGB(29,29,30)
ca.FontSize=5
ca.TextSize=14
ca.TextColor3=Color3.fromRGB(255,255,255)
ca.Text=""
ca.Font=3
ca.Parent=x
local da=Instance.new"ImageLabel"
da.Name="Arrow"
da.Size=UDim2.new(1,0,1,0)
da.BackgroundTransparency=1
da.BackgroundColor3=Color3.fromRGB(255,255,255)
da.Image="rbxassetid://5154078925"
da.Parent=ca
local ea=Instance.new"UIAspectRatioConstraint"
ea.Parent=ca
local fa=Instance.new"TextButton"
fa.Name="DecrementButton"
fa.ZIndex=2
fa.Size=UDim2.new(1,0,0.5,0)
fa.Position=UDim2.new(0,10,0,60)
fa.BorderSizePixel=0
fa.BackgroundColor3=Color3.fromRGB(29,29,30)
fa.FontSize=5
fa.TextSize=14
fa.TextColor3=Color3.fromRGB(255,255,255)
fa.Text=""
fa.Font=3
fa.Parent=x
local ga=Instance.new"ImageLabel"
ga.Name="Arrow"
ga.Size=UDim2.new(1,0,1,0)
ga.BackgroundTransparency=1
ga.BackgroundColor3=Color3.fromRGB(255,255,255)
ga.Image="rbxassetid://5143165549"
ga.Parent=fa
local ha=Instance.new"UIAspectRatioConstraint"
ha.Parent=fa
local ia=Instance.new"ModuleScript"
ia.Name="LazyLoader"
ia.Source="local GuiLib = script.Parent\r\nlocal FORMAT_STR = \"\\\"%s\\\" is not an existing class/folder.\"\r\n\r\nlocal VALID = {\r\n\t[\"Folder\"] = true;\r\n\t[\"ModuleScript\"] = true;\r\n}\r\n\r\nlocal function getLoaderOf(child)\r\n\tlocal Library = {}\r\n\tlocal Meta = {}\r\n\t\r\n\tfunction Meta:__index(key)\r\n\t\tif (Library[key]) then\r\n\t\t\treturn Library[key]\r\n\t\tend\r\n\t\t\r\n\t\tlocal object = child:FindFirstChild(key)\r\n\t\tif (object and object ~= script and VALID[object.ClassName]) then\r\n\t\t\tLibrary[key] = object:IsA(\"ModuleScript\") and require(object) or getLoaderOf(object)\r\n\t\t\treturn Library[key]\r\n\t\tend\r\n\t\t\r\n\t\terror(FORMAT_STR:format(key), 2)\r\n\tend\r\n\t\r\n\treturn setmetatable({}, Meta)\r\nend\r\n\r\nreturn getLoaderOf(GuiLib)"
ia.Parent=a
return a
